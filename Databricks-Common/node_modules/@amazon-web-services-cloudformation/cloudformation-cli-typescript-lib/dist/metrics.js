"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsPublisherProxy = exports.MetricsPublisher = exports.formatDimensions = void 0;
const cloudwatch_1 = __importDefault(require("aws-sdk/clients/cloudwatch"));
const interface_1 = require("./interface");
const utils_1 = require("./utils");
const METRIC_NAMESPACE_ROOT = 'AWS/CloudFormation';
function formatDimensions(dimensions) {
    const formatted = [];
    for (const key in dimensions) {
        const value = dimensions[key];
        const dimension = {
            Name: key,
            Value: value,
        };
        formatted.push(dimension);
    }
    return formatted;
}
exports.formatDimensions = formatDimensions;
class MetricsPublisher {
    constructor(session, logger, resourceType, workerPool) {
        this.session = session;
        this.logger = logger;
        this.resourceType = resourceType;
        this.workerPool = workerPool;
        this.resourceNamespace = resourceType.replace(/::/g, '/');
    }
    refreshClient(options) {
        this.client = this.session.client(cloudwatch_1.default, options, this.workerPool);
    }
    async publishMetric(metricName, dimensions, unit, value, timestamp) {
        if (!this.client) {
            throw Error('CloudWatch client was not initialized. You must call refreshClient() first.');
        }
        try {
            const metric = await this.client.makeRequestPromise('putMetricData', {
                Namespace: `${METRIC_NAMESPACE_ROOT}/${this.resourceNamespace}`,
                MetricData: [
                    {
                        MetricName: metricName,
                        Dimensions: formatDimensions(dimensions),
                        Unit: unit,
                        Timestamp: timestamp,
                        Value: value,
                    },
                ],
            });
            this.log('Response from "putMetricData"', metric);
        }
        catch (err) {
            if (err.retryable) {
                throw err;
            }
            else {
                this.log(`An error occurred while publishing metrics: ${err.message}`);
            }
        }
    }
    async publishExceptionMetric(timestamp, action, error) {
        const dimensions = {
            DimensionKeyActionType: action,
            DimensionKeyExceptionType: error.errorCode || error.constructor.name,
            DimensionKeyResourceType: this.resourceType,
        };
        return this.publishMetric(interface_1.MetricTypes.HandlerException, dimensions, interface_1.StandardUnit.Count, 1.0, timestamp);
    }
    async publishInvocationMetric(timestamp, action) {
        const dimensions = {
            DimensionKeyActionType: action,
            DimensionKeyResourceType: this.resourceType,
        };
        return this.publishMetric(interface_1.MetricTypes.HandlerInvocationCount, dimensions, interface_1.StandardUnit.Count, 1.0, timestamp);
    }
    async publishDurationMetric(timestamp, action, milliseconds) {
        const dimensions = {
            DimensionKeyActionType: action,
            DimensionKeyResourceType: this.resourceType,
        };
        return this.publishMetric(interface_1.MetricTypes.HandlerInvocationDuration, dimensions, interface_1.StandardUnit.Milliseconds, milliseconds, timestamp);
    }
    async publishLogDeliveryExceptionMetric(timestamp, error) {
        const dimensions = {
            DimensionKeyActionType: 'ProviderLogDelivery',
            DimensionKeyExceptionType: error.errorCode || error.constructor.name,
            DimensionKeyResourceType: this.resourceType,
        };
        try {
            return await this.publishMetric(interface_1.MetricTypes.HandlerException, dimensions, interface_1.StandardUnit.Count, 1.0, timestamp);
        }
        catch (err) {
            this.log(err);
        }
        return Promise.resolve(null);
    }
    log(message, ...optionalParams) {
        if (this.logger) {
            this.logger.log(message, ...optionalParams);
        }
    }
}
exports.MetricsPublisher = MetricsPublisher;
class MetricsPublisherProxy {
    constructor() {
        this.publishers = [];
        this.queue = new utils_1.Queue();
    }
    addMetricsPublisher(metricsPublisher) {
        if (metricsPublisher) {
            this.publishers.push(metricsPublisher);
        }
    }
    async publishExceptionMetric(timestamp, action, error) {
        for (const publisher of this.publishers) {
            await this.queue.enqueue(() => publisher.publishExceptionMetric(timestamp, action, error));
        }
    }
    async publishInvocationMetric(timestamp, action) {
        for (const publisher of this.publishers) {
            await this.queue.enqueue(() => publisher.publishInvocationMetric(timestamp, action));
        }
    }
    async publishDurationMetric(timestamp, action, milliseconds) {
        for (const publisher of this.publishers) {
            await this.queue.enqueue(() => publisher.publishDurationMetric(timestamp, action, milliseconds));
        }
    }
    async publishLogDeliveryExceptionMetric(timestamp, error) {
        for (const publisher of this.publishers) {
            await this.queue.enqueue(() => publisher.publishLogDeliveryExceptionMetric(timestamp, error));
        }
    }
}
exports.MetricsPublisherProxy = MetricsPublisherProxy;
