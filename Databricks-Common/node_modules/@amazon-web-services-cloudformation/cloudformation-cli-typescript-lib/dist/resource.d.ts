import 'reflect-metadata';
import { AwsTaskWorkerPool, ProgressEvent, SessionProxy } from './proxy';
import { Action, BaseModel, Callable, CfnResponse, Constructor, Dict, LambdaContext, Optional } from './interface';
import { Logger, LoggerProxy } from './log-delivery';
import { MetricsPublisherProxy } from './metrics';
export declare type HandlerSignature<T extends BaseModel, TypeConfiguration extends BaseModel> = Callable<[
    Optional<SessionProxy>,
    any,
    Dict,
    LoggerProxy,
    TypeConfiguration
], Promise<ProgressEvent<T>>>;
export declare class HandlerSignatures<T extends BaseModel, TypeConfiguration extends BaseModel> extends Map<Action, HandlerSignature<T, TypeConfiguration>> {
}
export declare abstract class BaseResource<T extends BaseModel = BaseModel, TypeConfiguration extends BaseModel = BaseModel> {
    readonly typeName: string;
    readonly modelTypeReference: Constructor<T>;
    protected readonly workerPool?: AwsTaskWorkerPool;
    private handlers?;
    readonly typeConfigurationTypeReference?: Constructor<TypeConfiguration> & {
        deserialize: Function;
    };
    protected loggerProxy: LoggerProxy;
    protected metricsPublisherProxy: MetricsPublisherProxy;
    protected lambdaLogger: Logger;
    protected platformLoggerProxy: LoggerProxy;
    private platformLambdaLogger;
    private providerSession;
    private callerSession;
    private providerMetricsPublisher;
    private cloudWatchLogHelper;
    private s3LogHelper;
    private providerEventsLogger;
    constructor(typeName: string, modelTypeReference: Constructor<T>, workerPool?: AwsTaskWorkerPool, handlers?: HandlerSignatures<T, TypeConfiguration>, typeConfigurationTypeReference?: Constructor<TypeConfiguration> & {
        deserialize: Function;
    });
    private initializeRuntime;
    private prepareCredentialsFilter;
    private waitRunningProcesses;
    private publishExceptionMetric;
    private log;
    addHandler: (action: Action, f: HandlerSignature<T, TypeConfiguration>) => HandlerSignature<T, TypeConfiguration>;
    private invokeHandler;
    private parseTestRequest;
    testEntrypoint(eventData: any | Dict, context?: Partial<LambdaContext>): Promise<ProgressEvent<T>>;
    private static parseRequest;
    private castResourceRequest;
    private castTypeConfigurationRequest;
    entrypoint(eventData: any | Dict, context: LambdaContext): Promise<CfnResponse<T>>;
}
export declare function handlerEvent(action: Action): MethodDecorator;
