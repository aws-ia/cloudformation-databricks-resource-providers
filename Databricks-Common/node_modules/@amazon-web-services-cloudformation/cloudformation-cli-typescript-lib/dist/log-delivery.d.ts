/// <reference types="node" />
import { InspectOptions } from 'util';
import { ServiceConfigurationOptions } from 'aws-sdk/lib/service';
import { AwsTaskWorkerPool, SessionProxy } from './proxy';
import { MetricsPublisherProxy } from './metrics';
import { ProgressTracker } from './utils';
declare type Console = globalThis.Console;
export declare type LambdaLogger = Partial<Console>;
export interface Logger {
    log(message?: any, ...optionalParams: any[]): void;
}
export interface LogFilter {
    applyFilter(rawInput: string): string;
}
export declare abstract class LogPublisher {
    protected readonly workerPool?: AwsTaskWorkerPool;
    private logFilters;
    constructor(workerPool?: AwsTaskWorkerPool, ...filters: readonly LogFilter[]);
    protected abstract publishMessage(message: string, eventTime?: Date): Promise<void>;
    private filterMessage;
    addFilter(filter: LogFilter): void;
    publishLogEvent(message: string, eventTime?: Date): Promise<void>;
}
export declare class LambdaLogPublisher extends LogPublisher {
    private readonly logger;
    constructor(logger: LambdaLogger, ...logFilters: readonly LogFilter[]);
    protected publishMessage(message: string): Promise<void>;
}
export declare class CloudWatchLogPublisher extends LogPublisher {
    private readonly session;
    private readonly logGroupName;
    private readonly logStreamName;
    private readonly platformLogger;
    private readonly metricsPublisherProxy?;
    protected readonly workerPool?: AwsTaskWorkerPool;
    private client;
    private queue;
    private nextSequenceToken;
    constructor(session: SessionProxy, logGroupName: string, logStreamName: string, platformLogger: Logger, metricsPublisherProxy?: MetricsPublisherProxy, workerPool?: AwsTaskWorkerPool, ...logFilters: readonly LogFilter[]);
    refreshClient(options?: ServiceConfigurationOptions): void;
    protected publishMessage(message: string, eventTime: Date): Promise<void>;
    private putLogEvents;
    populateSequenceToken(): Promise<string>;
    private skipLogging;
    private emitMetricsForLoggingFailure;
}
export declare class CloudWatchLogHelper {
    private readonly session;
    private logGroupName;
    private logStreamName;
    private readonly platformLogger;
    private readonly metricsPublisherProxy?;
    protected readonly workerPool?: AwsTaskWorkerPool;
    private client;
    constructor(session: SessionProxy, logGroupName: string, logStreamName: string, platformLogger: Logger, metricsPublisherProxy?: MetricsPublisherProxy, workerPool?: AwsTaskWorkerPool);
    refreshClient(options?: ServiceConfigurationOptions): void;
    prepareLogStream(): Promise<string | null>;
    private doesLogGroupExist;
    private createLogGroup;
    private createLogStream;
    private log;
    private emitMetricsForLoggingFailure;
}
export declare class S3LogPublisher extends LogPublisher {
    private readonly session;
    private readonly bucketName;
    private readonly folderName;
    private readonly platformLogger;
    private readonly metricsPublisherProxy?;
    protected readonly workerPool?: AwsTaskWorkerPool;
    private client;
    constructor(session: SessionProxy, bucketName: string, folderName: string, platformLogger: Logger, metricsPublisherProxy?: MetricsPublisherProxy, workerPool?: AwsTaskWorkerPool, ...logFilters: readonly LogFilter[]);
    refreshClient(options?: ServiceConfigurationOptions): void;
    protected publishMessage(message: string, eventTime: Date): Promise<void>;
    private skipLogging;
    private emitMetricsForLoggingFailure;
}
export declare class S3LogHelper {
    private readonly session;
    private bucketName;
    private folderName;
    private readonly platformLogger;
    private readonly metricsPublisherProxy?;
    protected readonly workerPool?: AwsTaskWorkerPool;
    private client;
    constructor(session: SessionProxy, bucketName: string, folderName: string, platformLogger: Logger, metricsPublisherProxy?: MetricsPublisherProxy, workerPool?: AwsTaskWorkerPool);
    refreshClient(options?: ServiceConfigurationOptions): void;
    prepareFolder(): Promise<string | null>;
    private doesFolderExist;
    private createBucket;
    private createFolder;
    private log;
    private emitMetricsForLoggingFailure;
}
export declare class LoggerProxy implements Logger {
    private readonly logPublishers;
    readonly tracker: ProgressTracker;
    constructor(defaultOptions?: InspectOptions);
    addLogPublisher(logPublisher: LogPublisher): void;
    addFilter(filter: LogFilter): void;
    waitCompletion(): Promise<boolean>;
    log(message?: any, ...optionalParams: any[]): void;
}
export {};
