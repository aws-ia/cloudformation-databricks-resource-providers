"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlerEvent = exports.BaseResource = exports.HandlerSignatures = void 0;
require("reflect-metadata");
const autobind_decorator_1 = require("autobind-decorator");
const proxy_1 = require("./proxy");
const exceptions_1 = require("./exceptions");
const interface_1 = require("./interface");
const log_delivery_1 = require("./log-delivery");
const metrics_1 = require("./metrics");
const utils_1 = require("./utils");
const MUTATING_ACTIONS = [
    interface_1.Action.Create,
    interface_1.Action.Update,
    interface_1.Action.Delete,
];
class HandlerSignatures extends Map {
}
exports.HandlerSignatures = HandlerSignatures;
class HandlerEvents extends Map {
}
function ensureSerialize(toResponse = false) {
    return function (target, propertyKey, descriptor) {
        if (descriptor === undefined) {
            descriptor = Object.getOwnPropertyDescriptor(target, propertyKey);
        }
        const originalMethod = descriptor.value;
        descriptor.value = async function (event, context) {
            const progress = await originalMethod.apply(this, [
                event,
                context,
            ]);
            if (toResponse) {
                const serialized = progress.serialize();
                return Promise.resolve(serialized);
            }
            return Promise.resolve(progress);
        };
        return descriptor;
    };
}
class BaseResource {
    constructor(typeName, modelTypeReference, workerPool, handlers, typeConfigurationTypeReference) {
        this.typeName = typeName;
        this.modelTypeReference = modelTypeReference;
        this.workerPool = workerPool;
        this.handlers = handlers;
        this.typeConfigurationTypeReference = typeConfigurationTypeReference;
        this.addHandler = (action, f) => {
            this.handlers.set(action, f);
            return f;
        };
        this.invokeHandler = async (session, request, action, callbackContext, typeConfiguration) => {
            const actionName = action == null ? '<null>' : action.toString();
            if (!this.handlers.has(action)) {
                throw new Error(`Unknown action ${actionName}`);
            }
            const handleRequest = this.handlers.get(action);
            utils_1.deepFreeze(callbackContext);
            utils_1.deepFreeze(request);
            this.log(`[${action}] invoking handler...`);
            const handlerResponse = await handleRequest(session, request, callbackContext, this.loggerProxy || this.platformLoggerProxy, typeConfiguration);
            this.log(`[${action}] handler invoked`);
            if (handlerResponse != null) {
                this.log('Handler returned %s', handlerResponse.status);
            }
            else {
                this.log('Handler returned null');
                throw new Error('Handler failed to provide a response.');
            }
            const isInProgress = handlerResponse.status === interface_1.OperationStatus.InProgress;
            const isMutable = MUTATING_ACTIONS.some((x) => x === action);
            if (isInProgress && !isMutable) {
                throw new exceptions_1.InternalFailure('READ and LIST handlers must return synchronously.');
            }
            return handlerResponse;
        };
        this.parseTestRequest = (eventData) => {
            let request;
            let action;
            let event;
            let callbackContext;
            try {
                event = interface_1.TestEvent.deserialize(eventData);
                const creds = event.credentials;
                if (!creds) {
                    throw new Error('Event data is missing required property "credentials".');
                }
                request = interface_1.UnmodeledRequest.deserialize(event.request).toModeled(this.modelTypeReference);
                this.callerSession = proxy_1.SessionProxy.getSession(creds, event.region);
                action = event.action;
                callbackContext = event.callbackContext || {};
            }
            catch (err) {
                this.log('Invalid request');
                throw new exceptions_1.InternalFailure(`${err} (${err.name})`);
            }
            return [request, action, callbackContext];
        };
        this.castResourceRequest = (request) => {
            try {
                const unmodeled = interface_1.UnmodeledRequest.fromUnmodeled({
                    clientRequestToken: request.bearerToken,
                    desiredResourceState: request.requestData.resourceProperties,
                    previousResourceState: request.requestData.previousResourceProperties,
                    desiredResourceTags: request.requestData.stackTags,
                    previousResourceTags: request.requestData.previousStackTags,
                    systemTags: request.requestData.systemTags,
                    awsAccountId: request.awsAccountId,
                    logicalResourceIdentifier: request.requestData.logicalResourceId,
                    region: request.region,
                });
                return unmodeled.toModeled(this.modelTypeReference);
            }
            catch (err) {
                this.log('Invalid request');
                throw new exceptions_1.InvalidRequest(`${err} (${err.name})`);
            }
        };
        this.castTypeConfigurationRequest = (request) => {
            try {
                if (!this.typeConfigurationTypeReference) {
                    if (request.requestData.typeConfiguration) {
                        throw new exceptions_1.InternalFailure('Type configuration supplied but running with legacy version of code which does not support type configuration.');
                    }
                    return null;
                }
                return this.typeConfigurationTypeReference.deserialize(request.requestData.typeConfiguration);
            }
            catch (err) {
                this.log('Invalid Type Configuration');
                throw new exceptions_1.InvalidTypeConfiguration(this.typeName, `${err} (${err.name}`);
            }
        };
        this.typeName = typeName || '';
        this.handlers = handlers || new HandlerSignatures();
        this.lambdaLogger = console;
        this.platformLoggerProxy = new log_delivery_1.LoggerProxy();
        this.platformLambdaLogger = new log_delivery_1.LambdaLogPublisher(this.lambdaLogger);
        this.platformLoggerProxy.addLogPublisher(this.platformLambdaLogger);
        const actions = Reflect.getMetadata('handlerEvents', this) || new HandlerEvents();
        actions.forEach((value, key) => {
            this.addHandler(key, this[value]);
        });
    }
    async initializeRuntime(resourceType, providerCredentials, providerLogGroupName, providerLogStreamName, region, awsAccountId) {
        this.loggerProxy = new log_delivery_1.LoggerProxy();
        this.metricsPublisherProxy = new metrics_1.MetricsPublisherProxy();
        this.loggerProxy.addLogPublisher(this.platformLambdaLogger);
        if (providerCredentials) {
            this.providerSession = proxy_1.SessionProxy.getSession(providerCredentials, region);
            this.providerMetricsPublisher = new metrics_1.MetricsPublisher(this.providerSession, this.platformLoggerProxy, resourceType, this.workerPool);
            this.metricsPublisherProxy.addMetricsPublisher(this.providerMetricsPublisher);
            this.providerMetricsPublisher.refreshClient();
            const logGroupName = `${providerLogGroupName}-${awsAccountId}`;
            this.s3LogHelper = new log_delivery_1.S3LogHelper(this.providerSession, logGroupName, providerLogStreamName, this.platformLoggerProxy, this.metricsPublisherProxy, this.workerPool);
            this.s3LogHelper.refreshClient();
            const folderName = await this.s3LogHelper.prepareFolder();
            let providerS3Logger = null;
            if (folderName) {
                providerS3Logger = new log_delivery_1.S3LogPublisher(this.providerSession, logGroupName, folderName, this.platformLoggerProxy, this.metricsPublisherProxy, this.workerPool);
                this.loggerProxy.addLogPublisher(providerS3Logger);
                providerS3Logger.refreshClient();
            }
            try {
                this.cloudWatchLogHelper = new log_delivery_1.CloudWatchLogHelper(this.providerSession, providerLogGroupName, providerLogStreamName, this.platformLoggerProxy, this.metricsPublisherProxy, this.workerPool);
                this.cloudWatchLogHelper.refreshClient();
                const logStreamName = await this.cloudWatchLogHelper.prepareLogStream();
                if (!logStreamName) {
                    throw new Error('Unable to setup CloudWatch logs.');
                }
                this.providerEventsLogger = new log_delivery_1.CloudWatchLogPublisher(this.providerSession, providerLogGroupName, logStreamName, this.platformLoggerProxy, this.metricsPublisherProxy, this.workerPool);
                this.loggerProxy.addLogPublisher(this.providerEventsLogger);
                this.providerEventsLogger.refreshClient();
                await this.providerEventsLogger.populateSequenceToken();
            }
            catch (err) {
                this.log(err);
                this.providerEventsLogger = providerS3Logger;
            }
        }
    }
    prepareCredentialsFilter(session) {
        var _a;
        const credentials = (_a = session === null || session === void 0 ? void 0 : session.configuration) === null || _a === void 0 ? void 0 : _a.credentials;
        if (credentials) {
            return {
                applyFilter: (message) => {
                    for (const value of Object.values(credentials)) {
                        message = utils_1.replaceAll(message, value, '<REDACTED>');
                    }
                    return message;
                },
            };
        }
        return null;
    }
    async waitRunningProcesses() {
        this.log('Waiting for logger proxy processes to finish...');
        if (this.workerPool) {
            this.log(`Prepare worker pool for shutdown.\tNumber of completed tasks: ${this.workerPool.completed}\tLength of time since instance was created: ${this.workerPool.duration} ms`);
        }
        await utils_1.delay(1);
        if (this.loggerProxy) {
            await this.loggerProxy.waitCompletion();
        }
        await this.platformLoggerProxy.waitCompletion();
        console.debug('Log delivery completed.');
        if (this.workerPool) {
            await this.workerPool.shutdown();
        }
    }
    async publishExceptionMetric(action, err) {
        if (this.metricsPublisherProxy) {
            await this.metricsPublisherProxy.publishExceptionMetric(new Date(Date.now()), action, err);
        }
        else {
            this.platformLoggerProxy.tracker.done = false;
            this.platformLoggerProxy.log(err.toString());
        }
    }
    log(message, ...optionalParams) {
        if (this.loggerProxy) {
            this.loggerProxy.tracker.done = false;
            this.loggerProxy.log(message, ...optionalParams);
        }
        else {
            this.platformLoggerProxy.tracker.done = false;
            this.platformLoggerProxy.log(message, ...optionalParams);
        }
    }
    async testEntrypoint(eventData, context) {
        let msg = 'Uninitialized';
        let progress;
        try {
            if (!this.modelTypeReference) {
                throw new exceptions_1.InternalFailure('Missing Model class to be used to deserialize JSON data.');
            }
            this.log(`START RequestId: ${context === null || context === void 0 ? void 0 : context.awsRequestId} Version: ${context === null || context === void 0 ? void 0 : context.functionVersion}`);
            this.log('EVENT DATA\n', eventData);
            const [request, action, callbackContext] = this.parseTestRequest(eventData);
            progress = await this.invokeHandler(this.callerSession, request, action, callbackContext);
        }
        catch (err) {
            if (!err.stack) {
                Error.captureStackTrace(err);
            }
            err.stack = `${new Error().stack}\n${err.stack}`;
            if (err instanceof exceptions_1.BaseHandlerException) {
                this.log(`Handler error: ${err.message}`, err);
                progress = err.toProgressEvent();
            }
            else {
                this.log(`Exception caught: ${err.message}`, err);
                msg = err.message || msg;
                progress = proxy_1.ProgressEvent.failed(interface_1.HandlerErrorCode.InternalFailure, msg);
            }
        }
        this.log(`END RequestId: ${context === null || context === void 0 ? void 0 : context.awsRequestId}`);
        await this.waitRunningProcesses();
        return Promise.resolve(progress);
    }
    async entrypoint(eventData, context) {
        var _a;
        let progress;
        let bearerToken;
        let milliseconds = null;
        try {
            if (!this.modelTypeReference) {
                throw new exceptions_1.InternalFailure('Missing Model class to be used to deserialize JSON data.');
            }
            const [credentials, action, callback, event] = BaseResource.parseRequest(eventData);
            bearerToken = event.bearerToken;
            const [callerCredentials, providerCredentials] = credentials;
            const request = this.castResourceRequest(event);
            const typeConfiguration = this.castTypeConfigurationRequest(event);
            let streamName = `${event.awsAccountId}-${event.region}`;
            if (event.stackId && request.logicalResourceIdentifier) {
                streamName = `${event.stackId}/${request.logicalResourceIdentifier}`;
            }
            await this.initializeRuntime(event.resourceType || this.typeName, providerCredentials, (_a = event.requestData) === null || _a === void 0 ? void 0 : _a.providerLogGroupName, streamName, event.region, event.awsAccountId);
            this.log(`START RequestId: ${context === null || context === void 0 ? void 0 : context.awsRequestId} Version: ${context === null || context === void 0 ? void 0 : context.functionVersion}`);
            const startTime = new Date(Date.now());
            await this.metricsPublisherProxy.publishInvocationMetric(startTime, action);
            let error;
            try {
                if (callerCredentials) {
                    this.callerSession = proxy_1.SessionProxy.getSession(callerCredentials, event.region);
                }
                if (this.loggerProxy) {
                    this.loggerProxy.addFilter({
                        applyFilter: (message) => {
                            return utils_1.replaceAll(message, bearerToken, '<REDACTED>');
                        },
                    });
                    this.loggerProxy.addFilter(this.prepareCredentialsFilter(this.providerSession));
                    this.loggerProxy.addFilter(this.prepareCredentialsFilter(this.callerSession));
                }
                this.log('EVENT DATA\n', eventData);
                progress = await this.invokeHandler(this.callerSession, request, action, callback, typeConfiguration);
            }
            catch (err) {
                error = err;
            }
            const endTime = new Date(Date.now());
            milliseconds = endTime.getTime() - startTime.getTime();
            await this.metricsPublisherProxy.publishDurationMetric(endTime, action, milliseconds);
            if (error) {
                await this.publishExceptionMetric(action, error);
                throw error;
            }
        }
        catch (err) {
            if (!err.stack) {
                Error.captureStackTrace(err);
            }
            err.stack = `${new Error().stack}\n${err.stack}`;
            if (err instanceof exceptions_1.BaseHandlerException) {
                this.log(`Handler error: ${err.message}`, err);
                progress = err.toProgressEvent();
            }
            else {
                this.log(`Exception caught: ${err.message}`, err);
                progress = proxy_1.ProgressEvent.failed(interface_1.HandlerErrorCode.InternalFailure, err.message);
            }
        }
        this.log(`END RequestId: ${context === null || context === void 0 ? void 0 : context.awsRequestId}`);
        this.log(`REPORT RequestId: ${context === null || context === void 0 ? void 0 : context.awsRequestId}\tDuration: ${milliseconds} ms\tMemory Size: ${context === null || context === void 0 ? void 0 : context.memoryLimitInMB} MB`);
        try {
            await this.waitRunningProcesses();
        }
        catch (err) {
            this.lambdaLogger.log(err);
            await utils_1.delay(2);
        }
        return progress;
    }
}
BaseResource.parseRequest = (eventData) => {
    let callerCredentials;
    let providerCredentials;
    let action;
    let callbackContext;
    let event;
    try {
        event = interface_1.HandlerRequest.deserialize(eventData);
        if (!event.awsAccountId) {
            throw new Error('Event data is missing required property "awsAccountId".');
        }
        callerCredentials = event.requestData.callerCredentials;
        providerCredentials = event.requestData.providerCredentials;
        action = event.action;
        callbackContext = event.callbackContext || {};
    }
    catch (err) {
        throw new exceptions_1.InvalidRequest(`${err} (${err.name})`);
    }
    return [
        [callerCredentials, providerCredentials],
        action,
        callbackContext,
        event,
    ];
};
__decorate([
    autobind_decorator_1.boundMethod,
    ensureSerialize(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], BaseResource.prototype, "testEntrypoint", null);
__decorate([
    autobind_decorator_1.boundMethod,
    ensureSerialize(true),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], BaseResource.prototype, "entrypoint", null);
exports.BaseResource = BaseResource;
function handlerEvent(action) {
    return function (target, propertyKey, descriptor) {
        if (target instanceof BaseResource) {
            const actions = Reflect.getMetadata('handlerEvents', target) || new HandlerEvents();
            if (!actions.has(action)) {
                actions.set(action, propertyKey);
            }
            Reflect.defineMetadata('handlerEvents', actions, target);
        }
        if (descriptor) {
            const boundDescriptor = autobind_decorator_1.boundMethod(target, propertyKey, descriptor);
            if (typeof descriptor.value === 'function' && boundDescriptor) {
                return boundDescriptor;
            }
            return descriptor;
        }
    };
}
exports.handlerEvent = handlerEvent;
