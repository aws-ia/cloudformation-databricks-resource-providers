"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var _tasksSubmitted, _tasksCompleted, _tasksFailed, _done, _queue, _pendingPromise;
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepFreeze = exports.replaceAll = exports.Queue = exports.ProgressTracker = exports.delay = void 0;
const events_1 = require("events");
const replaceAllShim = require('string.prototype.replaceall');
async function delay(seconds) {
    return new Promise((_) => setTimeout(() => _(), seconds * 1000));
}
exports.delay = delay;
class ProgressTracker extends events_1.EventEmitter {
    constructor() {
        super();
        _tasksSubmitted.set(this, void 0);
        _tasksCompleted.set(this, void 0);
        _tasksFailed.set(this, void 0);
        _done.set(this, void 0);
        this.restart();
        this.on('include', (kind) => {
            if (kind !== 'submitted' && this.isFinished) {
                process.nextTick(() => this.emit('finished'));
            }
        });
    }
    get done() {
        return __classPrivateFieldGet(this, _done);
    }
    set done(value) {
        __classPrivateFieldSet(this, _done, !!value);
    }
    end() {
        __classPrivateFieldSet(this, _done, true);
    }
    restart() {
        __classPrivateFieldSet(this, _tasksSubmitted, 0);
        __classPrivateFieldSet(this, _tasksCompleted, 0);
        __classPrivateFieldSet(this, _tasksFailed, 0);
        __classPrivateFieldSet(this, _done, false);
    }
    addSubmitted() {
        if (this.isFinished) {
            throw Error('Not allowed to submit a new task after progress tracker has been closed.');
        }
        __classPrivateFieldSet(this, _tasksSubmitted, +__classPrivateFieldGet(this, _tasksSubmitted) + 1);
        process.nextTick(() => this.emit('include', 'submitted'));
    }
    addCompleted() {
        __classPrivateFieldSet(this, _tasksCompleted, +__classPrivateFieldGet(this, _tasksCompleted) + 1);
        process.nextTick(() => this.emit('include', 'completed'));
    }
    addFailed() {
        __classPrivateFieldSet(this, _tasksFailed, +__classPrivateFieldGet(this, _tasksFailed) + 1);
        process.nextTick(() => this.emit('include', 'failed'));
    }
    get completed() {
        return __classPrivateFieldGet(this, _tasksCompleted) + __classPrivateFieldGet(this, _tasksFailed);
    }
    get isFinished() {
        return this.done && this.completed === __classPrivateFieldGet(this, _tasksSubmitted);
    }
    get message() {
        return (`${__classPrivateFieldGet(this, _tasksCompleted)} of ${__classPrivateFieldGet(this, _tasksSubmitted)} completed` +
            ` ${((__classPrivateFieldGet(this, _tasksCompleted) / __classPrivateFieldGet(this, _tasksSubmitted)) * 100).toFixed(2)}%` +
            ` [${__classPrivateFieldGet(this, _tasksFailed)} failed]`);
    }
    async waitCompletion() {
        await new Promise((resolve) => {
            if (this.isFinished) {
                resolve();
            }
            else {
                this.once('finished', resolve);
            }
        });
        this.restart();
    }
}
exports.ProgressTracker = ProgressTracker;
_tasksSubmitted = new WeakMap(), _tasksCompleted = new WeakMap(), _tasksFailed = new WeakMap(), _done = new WeakMap();
class Queue {
    constructor() {
        _queue.set(this, []);
        _pendingPromise.set(this, false);
    }
    enqueue(promise) {
        return new Promise((resolve, reject) => {
            __classPrivateFieldGet(this, _queue).push({
                promise,
                resolve,
                reject,
            });
            this.dequeue();
        });
    }
    dequeue() {
        if (__classPrivateFieldGet(this, _pendingPromise)) {
            return false;
        }
        const item = __classPrivateFieldGet(this, _queue).shift();
        if (!item) {
            return false;
        }
        try {
            __classPrivateFieldSet(this, _pendingPromise, true);
            item.promise()
                .then((value) => {
                __classPrivateFieldSet(this, _pendingPromise, false);
                item.resolve(value);
                this.dequeue();
            })
                .catch((err) => {
                __classPrivateFieldSet(this, _pendingPromise, false);
                item.reject(err);
                this.dequeue();
            });
        }
        catch (err) {
            __classPrivateFieldSet(this, _pendingPromise, false);
            item.reject(err);
            this.dequeue();
        }
        return true;
    }
}
exports.Queue = Queue;
_queue = new WeakMap(), _pendingPromise = new WeakMap();
function replaceAll(original, substr, newSubstr) {
    if (original) {
        return replaceAllShim(original, substr, newSubstr);
    }
    return original;
}
exports.replaceAll = replaceAll;
function deepFreeze(obj, processed = new Set()) {
    if (processed.has(obj) ||
        !obj ||
        obj === Function.prototype ||
        !(typeof obj === 'object' || typeof obj === 'function' || Array.isArray(obj)) ||
        ArrayBuffer.isView(obj)) {
        return obj;
    }
    processed.add(obj);
    let propNames = Object.getOwnPropertyNames(obj);
    if (Object.getOwnPropertySymbols) {
        propNames = propNames.concat(Object.getOwnPropertySymbols(obj));
    }
    for (const name of propNames) {
        const value = obj[name];
        deepFreeze(value, processed);
    }
    return Object.isFrozen(obj) ? obj : Object.freeze(obj);
}
exports.deepFreeze = deepFreeze;
