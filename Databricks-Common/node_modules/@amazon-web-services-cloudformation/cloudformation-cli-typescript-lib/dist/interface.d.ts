import 'reflect-metadata';
import { ClientRequestToken, LogGroupName, LogicalResourceId, NextToken } from 'aws-sdk/clients/cloudformation';
import { Service } from 'aws-sdk/lib/service';
import { classToPlain, ClassTransformOptions, plainToClass } from 'class-transformer';
export declare type Optional<T> = T | undefined | null;
export declare type Dict<T = any> = Record<string, T>;
export declare type Constructor<T = {}> = new (...args: any[]) => T;
export declare type integer = bigint;
export declare type InstanceProperties<T extends object = Service, C extends Constructor<T> = Constructor<T>> = keyof InstanceType<C>;
export declare type ServiceProperties<S extends Service = Service, C extends Constructor<S> = Constructor<S>> = Exclude<InstanceProperties<S, C>, InstanceProperties<Service, Constructor<Service>>>;
export declare type OverloadedArguments<T> = T extends {
    (...args: any[]): any;
    (params: infer P, callback: any): any;
    (callback: any): any;
} ? P : T extends {
    (params: infer P, callback: any): any;
    (callback: any): any;
} ? P : T extends (params: infer P, callback: any) => any ? P : any;
export declare type OverloadedReturnType<T> = T extends {
    (...args: any[]): any;
    (params: any, callback: any): infer R;
    (callback: any): any;
} ? R : T extends {
    (params: any, callback: any): infer R;
    (callback: any): any;
} ? R : T extends (callback: any) => infer R ? R : any;
export interface Callable<R extends Array<any>, T> {
    (...args: R): T;
}
interface Integer extends BigInt {
    toJSON(): number;
    valueOf(): integer;
}
interface IntegerConstructor extends BigIntConstructor {
    (value?: unknown): integer;
    readonly prototype: Integer;
    isSafeInteger(value: unknown): boolean;
}
export declare const Integer: IntegerConstructor;
export declare enum Action {
    Create = "CREATE",
    Read = "READ",
    Update = "UPDATE",
    Delete = "DELETE",
    List = "LIST"
}
export declare enum StandardUnit {
    Count = "Count",
    Milliseconds = "Milliseconds"
}
export declare enum MetricTypes {
    HandlerException = "HandlerException",
    HandlerInvocationCount = "HandlerInvocationCount",
    HandlerInvocationDuration = "HandlerInvocationDuration"
}
export declare enum OperationStatus {
    Pending = "PENDING",
    InProgress = "IN_PROGRESS",
    Success = "SUCCESS",
    Failed = "FAILED"
}
export declare enum HandlerErrorCode {
    NotUpdatable = "NotUpdatable",
    InvalidRequest = "InvalidRequest",
    AccessDenied = "AccessDenied",
    InvalidCredentials = "InvalidCredentials",
    AlreadyExists = "AlreadyExists",
    NotFound = "NotFound",
    ResourceConflict = "ResourceConflict",
    Throttling = "Throttling",
    ServiceLimitExceeded = "ServiceLimitExceeded",
    NotStabilized = "NotStabilized",
    GeneralServiceException = "GeneralServiceException",
    ServiceInternalError = "ServiceInternalError",
    NetworkFailure = "NetworkFailure",
    InternalFailure = "InternalFailure",
    InvalidTypeConfiguration = "InvalidTypeConfiguration"
}
export interface Credentials {
    accessKeyId: string;
    secretAccessKey: string;
    sessionToken: string;
}
export declare abstract class BaseDto {
    constructor(partial?: unknown);
    static serializer: {
        classToPlain: typeof classToPlain;
        plainToClass: typeof plainToClass;
    };
    serialize(removeNull?: boolean): Dict;
    static deserialize<T extends BaseDto>(this: new () => T, jsonData: Dict, options?: ClassTransformOptions): T;
    toJSON(key?: string): Dict;
}
export interface RequestContext<T> {
    invocation: number;
    callbackContext: T;
    cloudWatchEventsRuleName: string;
    cloudWatchEventsTargetId: string;
}
export declare class BaseModel extends BaseDto {
    ['constructor']: typeof BaseModel;
    protected static readonly TYPE_NAME?: string;
    getTypeName(): string;
}
export declare class TestEvent extends BaseDto {
    credentials: Credentials;
    action: Action;
    request: Dict;
    callbackContext: Dict;
    region?: string;
}
export declare class RequestData<T = Dict> extends BaseDto {
    resourceProperties: T;
    providerLogGroupName?: LogGroupName;
    logicalResourceId?: LogicalResourceId;
    systemTags?: Dict<string>;
    stackTags?: Dict<string>;
    callerCredentials?: Credentials;
    providerCredentials?: Credentials;
    previousResourceProperties?: T;
    previousStackTags?: Dict<string>;
    typeConfiguration?: Dict<string>;
}
export declare class HandlerRequest<ResourceT = Dict, CallbackT = Dict> extends BaseDto {
    action: Action;
    awsAccountId: string;
    bearerToken: string;
    region: string;
    requestData: RequestData<ResourceT>;
    responseEndpoint?: string;
    stackId?: string;
    resourceType?: string;
    resourceTypeVersion?: string;
    callbackContext?: CallbackT;
    nextToken?: NextToken;
    requestContext?: RequestContext<CallbackT>;
}
export declare class BaseResourceHandlerRequest<T extends BaseModel> extends BaseDto {
    clientRequestToken: ClientRequestToken;
    desiredResourceState?: T;
    previousResourceState?: T;
    desiredResourceTags: Dict<string>;
    previousResourceTags: Dict<string>;
    systemTags: Dict<string>;
    awsAccountId: string;
    awsPartition: string;
    logicalResourceIdentifier?: LogicalResourceId;
    nextToken?: NextToken;
    region: string;
}
export declare class UnmodeledRequest extends BaseResourceHandlerRequest<BaseModel> {
    static fromUnmodeled(obj: Dict): UnmodeledRequest;
    static getPartition(region: Optional<string>): Optional<string>;
    toModeled<T extends BaseModel = BaseModel>(modelTypeReference: Constructor<T> & {
        deserialize?: Function;
    }): BaseResourceHandlerRequest<T>;
}
export interface CfnResponse<T extends BaseModel> {
    errorCode?: HandlerErrorCode;
    status: OperationStatus;
    message: string;
    resourceModel?: T;
    resourceModels?: T[];
    nextToken?: NextToken;
}
export interface LambdaContext {
    functionName?: string;
    functionVersion?: string;
    invokedFunctionArn?: string;
    memoryLimitInMB?: number;
    awsRequestId?: string;
    callbackWaitsForEmptyEventLoop?: boolean;
    getRemainingTimeInMillis(): number;
}
export {};
