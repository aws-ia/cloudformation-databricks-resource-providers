"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggerProxy = exports.S3LogHelper = exports.S3LogPublisher = exports.CloudWatchLogHelper = exports.CloudWatchLogPublisher = exports.LambdaLogPublisher = exports.LogPublisher = void 0;
const util_1 = require("util");
const cloudwatchlogs_1 = __importDefault(require("aws-sdk/clients/cloudwatchlogs"));
const s3_1 = __importDefault(require("aws-sdk/clients/s3"));
const uuid_1 = require("uuid");
const utils_1 = require("./utils");
class LogPublisher {
    constructor(workerPool, ...filters) {
        this.workerPool = workerPool;
        this.logFilters = Array.from(filters);
    }
    filterMessage(message) {
        let toReturn = message;
        this.logFilters.forEach((filter) => {
            toReturn = filter.applyFilter(toReturn);
        });
        return toReturn;
    }
    addFilter(filter) {
        if (filter) {
            this.logFilters.push(filter);
        }
    }
    async publishLogEvent(message, eventTime) {
        if (!eventTime) {
            eventTime = new Date(Date.now());
        }
        await this.publishMessage(this.filterMessage(message), eventTime);
    }
}
exports.LogPublisher = LogPublisher;
class LambdaLogPublisher extends LogPublisher {
    constructor(logger, ...logFilters) {
        super(null, ...logFilters);
        this.logger = logger;
    }
    async publishMessage(message) {
        return Promise.resolve(this.logger.log('%s\n', message));
    }
}
exports.LambdaLogPublisher = LambdaLogPublisher;
class CloudWatchLogPublisher extends LogPublisher {
    constructor(session, logGroupName, logStreamName, platformLogger, metricsPublisherProxy, workerPool, ...logFilters) {
        super(workerPool, ...logFilters);
        this.session = session;
        this.logGroupName = logGroupName;
        this.logStreamName = logStreamName;
        this.platformLogger = platformLogger;
        this.metricsPublisherProxy = metricsPublisherProxy;
        this.workerPool = workerPool;
        this.queue = new utils_1.Queue();
        this.nextSequenceToken = null;
    }
    refreshClient(options) {
        this.client = this.session.client(cloudwatchlogs_1.default, options, this.workerPool);
    }
    async publishMessage(message, eventTime) {
        if (this.skipLogging()) {
            return;
        }
        if (!this.client) {
            throw Error('CloudWatchLogs client was not initialized. You must call refreshClient() first.');
        }
        return await this.queue.enqueue(async () => {
            const record = {
                message,
                timestamp: Math.round(eventTime.getTime()),
            };
            try {
                this.nextSequenceToken = await this.putLogEvents(record, this.nextSequenceToken);
                return;
            }
            catch (err) {
                const errorCode = err.code || err.name;
                this.platformLogger.log(`Error from "putLogEvents" with sequence token ${this.nextSequenceToken}`, JSON.stringify(err));
                if (errorCode === 'DataAlreadyAcceptedException' ||
                    errorCode === 'InvalidSequenceTokenException' ||
                    errorCode === 'ThrottlingException') {
                    await utils_1.delay(0.25);
                    const result = (err.message || '').match(/sequencetoken( is)?: (.+)/i);
                    if ((result === null || result === void 0 ? void 0 : result.length) === 3 && result[2]) {
                        this.nextSequenceToken = result[2];
                    }
                    else {
                        await this.populateSequenceToken();
                    }
                    await this.emitMetricsForLoggingFailure(err);
                    err.retryable = true;
                    err.message = `Publishing this log event should be retried. ${err.message}`;
                }
                else {
                    this.platformLogger.log(`An error occurred while putting log events [${message}] to resource owner account, with error: ${err.toString()}`);
                }
                await this.emitMetricsForLoggingFailure(err);
                throw err;
            }
        });
    }
    async putLogEvents(record, sequenceToken = undefined) {
        await utils_1.delay(0.25);
        const response = await this.client.makeRequestPromise('putLogEvents', {
            logGroupName: this.logGroupName,
            logStreamName: this.logStreamName,
            logEvents: [record],
            sequenceToken,
        }, { 'X-Amzn-Logs-Format': 'json/emf' });
        this.platformLogger.log('Response from "putLogEvents"', response);
        if (response === null || response === void 0 ? void 0 : response.rejectedLogEventsInfo) {
            throw new Error(JSON.stringify(response.rejectedLogEventsInfo));
        }
        return (response === null || response === void 0 ? void 0 : response.nextSequenceToken) || null;
    }
    async populateSequenceToken() {
        var _a;
        this.nextSequenceToken = null;
        try {
            const response = await this.client.makeRequestPromise('describeLogStreams', {
                logGroupName: this.logGroupName,
                logStreamNamePrefix: this.logStreamName,
                limit: 1,
            });
            this.platformLogger.log('Response from "describeLogStreams"', response);
            if ((_a = response.logStreams) === null || _a === void 0 ? void 0 : _a.length) {
                const logStream = response.logStreams[0];
                this.nextSequenceToken = logStream.uploadSequenceToken;
            }
        }
        catch (err) {
            this.platformLogger.log('Error from "describeLogStreams"', err);
        }
        return this.nextSequenceToken;
    }
    skipLogging() {
        return !(this.logGroupName && this.logStreamName);
    }
    async emitMetricsForLoggingFailure(err) {
        if (this.metricsPublisherProxy) {
            await this.metricsPublisherProxy.publishLogDeliveryExceptionMetric(new Date(Date.now()), err);
        }
    }
}
exports.CloudWatchLogPublisher = CloudWatchLogPublisher;
class CloudWatchLogHelper {
    constructor(session, logGroupName, logStreamName, platformLogger, metricsPublisherProxy, workerPool) {
        this.session = session;
        this.logGroupName = logGroupName;
        this.logStreamName = logStreamName;
        this.platformLogger = platformLogger;
        this.metricsPublisherProxy = metricsPublisherProxy;
        this.workerPool = workerPool;
        if (!this.logStreamName) {
            this.logStreamName = uuid_1.v4();
        }
        else {
            this.logStreamName = logStreamName.replace(/:/g, '__');
        }
    }
    refreshClient(options) {
        this.client = this.session.client(cloudwatchlogs_1.default, options, this.workerPool);
    }
    async prepareLogStream() {
        if (!this.client) {
            throw Error('CloudWatchLogs client was not initialized. You must call refreshClient() first.');
        }
        try {
            if (!(await this.doesLogGroupExist())) {
                await this.createLogGroup();
            }
            return await this.createLogStream();
        }
        catch (err) {
            this.log(`Initializing logging group setting failed with error: ${err.toString()}`);
            await this.emitMetricsForLoggingFailure(err);
        }
        return Promise.resolve(null);
    }
    async doesLogGroupExist() {
        var _a;
        let logGroupExists = false;
        try {
            const response = await this.client.makeRequestPromise('describeLogGroups', {
                logGroupNamePrefix: this.logGroupName,
            });
            this.log('Response from "describeLogGroups"', response);
            if ((_a = response.logGroups) === null || _a === void 0 ? void 0 : _a.length) {
                logGroupExists = response.logGroups.some((logGroup) => {
                    return logGroup.logGroupName === this.logGroupName;
                });
            }
        }
        catch (err) {
            this.log(err);
            await this.emitMetricsForLoggingFailure(err);
        }
        this.log(`Log group with name ${this.logGroupName} does${logGroupExists ? '' : ' not'} exist in resource owner account.`);
        return Promise.resolve(logGroupExists);
    }
    async createLogGroup() {
        try {
            this.log(`Creating Log group with name ${this.logGroupName}.`);
            const response = await this.client.makeRequestPromise('createLogGroup', {
                logGroupName: this.logGroupName,
            });
            this.log('Response from "createLogGroup"', response);
        }
        catch (err) {
            const errorCode = err.code || err.name;
            if (errorCode !== 'ResourceAlreadyExistsException') {
                throw err;
            }
        }
        return Promise.resolve(this.logGroupName);
    }
    async createLogStream() {
        try {
            this.log(`Creating Log stream with name ${this.logStreamName} for log group ${this.logGroupName}.`);
            const response = await this.client.makeRequestPromise('createLogStream', {
                logGroupName: this.logGroupName,
                logStreamName: this.logStreamName,
            });
            this.log('Response from "createLogStream"', response);
        }
        catch (err) {
            const errorCode = err.code || err.name;
            if (errorCode !== 'ResourceAlreadyExistsException') {
                throw err;
            }
        }
        return Promise.resolve(this.logStreamName);
    }
    log(message, ...optionalParams) {
        if (this.platformLogger) {
            this.platformLogger.log(message, ...optionalParams);
        }
    }
    async emitMetricsForLoggingFailure(err) {
        if (this.metricsPublisherProxy) {
            await this.metricsPublisherProxy.publishLogDeliveryExceptionMetric(new Date(Date.now()), err);
        }
    }
}
exports.CloudWatchLogHelper = CloudWatchLogHelper;
class S3LogPublisher extends LogPublisher {
    constructor(session, bucketName, folderName, platformLogger, metricsPublisherProxy, workerPool, ...logFilters) {
        super(workerPool, ...logFilters);
        this.session = session;
        this.bucketName = bucketName;
        this.folderName = folderName;
        this.platformLogger = platformLogger;
        this.metricsPublisherProxy = metricsPublisherProxy;
        this.workerPool = workerPool;
    }
    refreshClient(options) {
        this.client = this.session.client(s3_1.default, options, this.workerPool);
    }
    async publishMessage(message, eventTime) {
        if (this.skipLogging()) {
            return;
        }
        if (!this.client) {
            throw Error('S3 client was not initialized. You must call refreshClient() first.');
        }
        try {
            const timestamp = eventTime.toISOString().replace(/[^a-z0-9]/gi, '');
            const putObjectParams = {
                Bucket: this.bucketName,
                Key: `${this.folderName}/${timestamp}-${Math.floor(Math.random() * 100)}.log`,
                ContentType: 'text/plain',
                Body: message,
            };
            const response = await this.client.makeRequestPromise('putObject', putObjectParams);
            this.platformLogger.log('Response from "putObject"', response);
            return;
        }
        catch (err) {
            this.platformLogger.log(`An error occurred while putting log events [${message}] to resource owner account, with error: ${err.toString()}`);
            await this.emitMetricsForLoggingFailure(err);
            throw err;
        }
    }
    skipLogging() {
        return !(this.bucketName && this.folderName);
    }
    async emitMetricsForLoggingFailure(err) {
        if (this.metricsPublisherProxy) {
            await this.metricsPublisherProxy.publishLogDeliveryExceptionMetric(new Date(Date.now()), err);
        }
    }
}
exports.S3LogPublisher = S3LogPublisher;
class S3LogHelper {
    constructor(session, bucketName, folderName, platformLogger, metricsPublisherProxy, workerPool) {
        this.session = session;
        this.bucketName = bucketName;
        this.folderName = folderName;
        this.platformLogger = platformLogger;
        this.metricsPublisherProxy = metricsPublisherProxy;
        this.workerPool = workerPool;
        if (!this.folderName) {
            this.folderName = uuid_1.v4();
        }
        this.folderName = this.folderName.replace(/[^a-z0-9!_'.*()/-]/gi, '_');
    }
    refreshClient(options) {
        this.client = this.session.client(s3_1.default, options, this.workerPool);
    }
    async prepareFolder() {
        if (!this.client) {
            throw Error('S3 client was not initialized. You must call refreshClient() first.');
        }
        try {
            const folderExists = await this.doesFolderExist();
            if (folderExists === null) {
                await this.createBucket();
            }
            if (folderExists === true) {
                return this.folderName;
            }
            else {
                return await this.createFolder();
            }
        }
        catch (err) {
            this.log(`Initializing S3 bucket and folder failed with error: ${err.toString()}`);
            await this.emitMetricsForLoggingFailure(err);
        }
        return null;
    }
    async doesFolderExist() {
        var _a;
        let folderExists = false;
        try {
            const response = await this.client.makeRequestPromise('listObjectsV2', {
                Bucket: this.bucketName,
                Prefix: `${this.folderName}/`,
            });
            this.log('Response from "listObjects"', response);
            if ((_a = response.Contents) === null || _a === void 0 ? void 0 : _a.length) {
                folderExists = true;
            }
            this.log(`S3 folder with name ${this.folderName} does${folderExists ? '' : ' not'} exist in bucket ${this.bucketName}.`);
            return Promise.resolve(folderExists);
        }
        catch (err) {
            const errorCode = err.code || err.name;
            if (errorCode === 'NoSuchBucket') {
                this.log(`S3 bucket with name ${this.bucketName} does exist in resource owner account.`);
            }
            this.log(err);
            await this.emitMetricsForLoggingFailure(err);
            return Promise.resolve(null);
        }
    }
    async createBucket() {
        try {
            this.log(`Creating S3 bucket with name ${this.bucketName}.`);
            const response = await this.client.makeRequestPromise('createBucket', {
                Bucket: this.bucketName,
            });
            this.log('Response from "createBucket"', response);
        }
        catch (err) {
            const errorCode = err.code || err.name;
            if (errorCode !== 'BucketAlreadyOwnedByYou' &&
                errorCode !== 'BucketAlreadyExists') {
                throw err;
            }
        }
        return Promise.resolve(this.bucketName);
    }
    async createFolder() {
        try {
            this.log(`Creating folder with name ${this.folderName} for bucket ${this.bucketName}.`);
            const response = await this.client.makeRequestPromise('putObject', {
                Bucket: this.bucketName,
                Key: `${this.folderName}/`,
                ContentLength: 0,
            });
            this.log('Response from "putObject"', response);
        }
        catch (err) {
            throw err;
        }
        return Promise.resolve(this.folderName);
    }
    log(message, ...optionalParams) {
        if (this.platformLogger) {
            this.platformLogger.log(message, ...optionalParams);
        }
    }
    async emitMetricsForLoggingFailure(err) {
        if (this.metricsPublisherProxy) {
            await this.metricsPublisherProxy.publishLogDeliveryExceptionMetric(new Date(Date.now()), err);
        }
    }
}
exports.S3LogHelper = S3LogHelper;
class LoggerProxy {
    constructor(defaultOptions = {}) {
        this.logPublishers = new Array();
        this.tracker = new utils_1.ProgressTracker();
        util_1.inspect.defaultOptions = {
            ...util_1.inspect.defaultOptions,
            depth: 10,
            ...defaultOptions,
        };
    }
    addLogPublisher(logPublisher) {
        if (logPublisher) {
            this.logPublishers.push(logPublisher);
        }
    }
    addFilter(filter) {
        this.logPublishers.forEach((logPublisher) => {
            logPublisher.addFilter(filter);
        });
    }
    async waitCompletion() {
        try {
            this.tracker.end();
            await this.tracker.waitCompletion();
        }
        catch (err) {
            console.error(err);
        }
        return Promise.resolve(true);
    }
    log(message, ...optionalParams) {
        const formatted = util_1.format(message, ...optionalParams);
        const eventTime = new Date(Date.now());
        for (const logPublisher of this.logPublishers) {
            this.tracker.addSubmitted();
            (async () => {
                try {
                    await logPublisher.publishLogEvent(formatted, eventTime);
                    this.tracker.addCompleted();
                }
                catch (err) {
                    console.error(err);
                    if (err.retryable === true) {
                        try {
                            await logPublisher.publishLogEvent(formatted, eventTime);
                            this.tracker.addCompleted();
                        }
                        catch (err) {
                            console.error(err);
                            this.tracker.addFailed();
                        }
                    }
                    else {
                        this.tracker.addFailed();
                    }
                }
            })();
        }
    }
}
exports.LoggerProxy = LoggerProxy;
