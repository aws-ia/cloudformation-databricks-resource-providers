/// <reference types="node" />
import { AWSError } from 'aws-sdk';
import Aws from 'aws-sdk/clients/all';
import { NextToken } from 'aws-sdk/clients/cloudformation';
import { CredentialsOptions } from 'aws-sdk/lib/credentials';
import { PromiseResult } from 'aws-sdk/lib/request';
import { Service, ServiceConfigurationOptions } from 'aws-sdk/lib/service';
import { EventEmitter } from 'events';
import { IBuilder } from '@org-formation/tombok';
import { BaseDto, BaseResourceHandlerRequest, BaseModel, Constructor, Dict, HandlerErrorCode, OperationStatus, OverloadedArguments, ServiceProperties } from './interface';
declare type ClientMap = typeof Aws;
export declare type ClientName = keyof ClientMap;
export declare type Client = InstanceType<ClientMap[ClientName]>;
export declare type Result<T> = T extends (...args: any) => infer R ? R : any;
export declare type Input<T> = T extends (...args: infer P) => any ? P : never;
export declare type ServiceOptions<S extends Service = Service> = ConstructorParameters<Constructor<S>>[0];
export declare type ServiceOperation<S extends Service = Service, C extends Constructor<S> = Constructor<S>, O extends ServiceProperties<S, C> = ServiceProperties<S, C>, E extends Error = AWSError> = InstanceType<C>[O] & {
    promise(): Promise<PromiseResult<any, E>>;
};
export declare type InferredResult<S extends Service = Service, C extends Constructor<S> = Constructor<S>, O extends ServiceProperties<S, C> = ServiceProperties<S, C>, E extends Error = AWSError, N extends ServiceOperation<S, C, O, E> = ServiceOperation<S, C, O, E>> = Input<Input<Result<Result<N>['promise']>['then']>[0]>[0];
declare type AwsTaskSignature = <S extends Service = Service, C extends Constructor<S> = Constructor<S>, O extends ServiceProperties<S, C> = ServiceProperties<S, C>, E extends Error = AWSError, N extends ServiceOperation<S, C, O, E> = ServiceOperation<S, C, O, E>>(params: any) => Promise<InferredResult<S, C, O, E, N>>;
export declare type ExtendedClient<S extends Service = Service> = S & {
    serviceIdentifier?: string;
    makeRequestPromise?: <C extends Constructor<S> = Constructor<S>, O extends ServiceProperties<S, C> = ServiceProperties<S, C>, E extends Error = AWSError, N extends ServiceOperation<S, C, O, E> = ServiceOperation<S, C, O, E>>(operation: O, input?: OverloadedArguments<N>, headers?: Record<string, string>) => Promise<InferredResult<S, C, O, E, N>>;
};
export interface AwsTaskWorkerPool extends EventEmitter {
    runAwsTask: AwsTaskSignature;
    shutdown: (doDestroy?: boolean) => Promise<boolean>;
    completed?: number;
    duration?: number;
}
export interface Session {
    client: <S extends Service>(service: ClientName | S | Constructor<S>, options?: ServiceConfigurationOptions) => ExtendedClient<S>;
}
export declare class SessionProxy implements Session {
    private options;
    constructor(options: ServiceConfigurationOptions);
    private extendAwsClient;
    client<S extends Service = Service>(service: ClientName | S | Constructor<S>, options?: ServiceConfigurationOptions, workerPool?: AwsTaskWorkerPool): ExtendedClient<S>;
    get configuration(): ServiceConfigurationOptions;
    static getSession(credentials?: CredentialsOptions, region?: string): SessionProxy | null;
}
export declare class ProgressEvent<ResourceT extends BaseModel = BaseModel, CallbackT = Dict> extends BaseDto {
    status: OperationStatus;
    errorCode?: HandlerErrorCode;
    message: string;
    callbackContext?: CallbackT;
    callbackDelaySeconds: number;
    resourceModel?: ResourceT;
    resourceModels?: Array<ResourceT>;
    nextToken?: NextToken;
    constructor(partial?: Partial<ProgressEvent>);
    static builder<T extends ProgressEvent>(template?: Partial<T>): IBuilder<T>;
    static failed<T extends ProgressEvent>(errorCode: HandlerErrorCode, message: string): T;
    static progress<T extends ProgressEvent>(model?: any, ctx?: any): T;
    static success<T extends ProgressEvent>(model?: any, ctx?: any): T;
}
export declare class ResourceHandlerRequest<T extends BaseModel> extends BaseResourceHandlerRequest<T> {
}
export {};
